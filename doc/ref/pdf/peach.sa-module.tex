%
% API Documentation for Peach - Computational Intelligence for Python
% Package peach.sa
%
% Generated by epydoc 3.0.1
% [Fri Feb  4 17:21:22 2011]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.sa \textit{(package)}|(}
\section{Package peach.sa}

    \label{peach:sa}

This package implements optimization by simulated annealing. Consult:
%
\begin{quote}
%
\begin{description}
\item[{base}] \leavevmode 
Implementation of the basic simulated annealing algorithms;

\item[{neighbor}] \leavevmode 
Some methods for determining the neighbor of the present estimate;

\end{description}

\end{quote}

Simulated Annealing is a meta-heuristic designed for optimization of functions.
It tries to mimic the way that atoms settle in crystal structures of metals. By
slowly cooling the metal, atoms settle in a position of low energy -{}- thus, it
is a natural optimization method.

Two kinds of optimizer are implemented here. The continuous version of the
algorithm can be used for optimization of continuous objective functions; the
discrete (or binary) one, can be used in combinatorial optimization problems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Modules                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Modules}

\begin{itemize}
\setlength{\parskip}{0ex}
\item \textbf{base}: 
This package implements two versions of simulated annealing optimization. One
works with numeric data, and the other with a codified bit string. This last
method can be used in discrete optimization problems.


  \textit{(Section \ref{peach:sa:base}, p.~\pageref{peach:sa:base})}

\item \textbf{neighbor}: 
This module implements a general class to compute neighbors for continuous and
binary simulated annealing algorithms. The continuous neighbor functions return
an array with a neighbor of a given estimate; the binary neighbor functions
return a \texttt{bitarray} object.


  \textit{(Section \ref{peach:sa:neighbor}, p.~\pageref{peach:sa:neighbor})}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{peach:standard_normal}
    \index{peach \textit{(package)}!peach.standard\_normal \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{standard\_normal}(\textit{size}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Returns samples from a Standard Normal distribution (mean=0, stdev=1).


%___________________________________________________________________________

\paragraph*{Parameters%
  \phantomsection%
  \addcontentsline{toc}{paragraph}{Parameters}%
  \label{parameters}%
}
%
\begin{description}
\item[{size}] \leavevmode (\textbf{int, shape tuple, optional})

Returns the number of samples required to satisfy the \texttt{size} parameter.
If not given or 'None' indicates to return one sample.

\end{description}


%___________________________________________________________________________

\paragraph*{Returns%
  \phantomsection%
  \addcontentsline{toc}{paragraph}{Returns}%
  \label{returns}%
}
%
\begin{description}
\item[{out}] \leavevmode (\textbf{float, ndarray})

Samples the Standard Normal distribution with a shape satisfying the
\texttt{size} parameter.

\end{description}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{peach:ga:uniform}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.uniform \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{uniform}(\textit{low}={\tt 0.0}, \textit{high}={\tt 1.0}, \textit{size}={\tt 1})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
Draw samples from a uniform distribution.

Samples are uniformly distributed over the half-open interval
``[low, high)`` (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by `uniform`.

Parameters
----------
low : float, optional
    Lower boundary of the output interval.  All values generated will be
    greater than or equal to low.  The default value is 0.
high : float
    Upper boundary of the output interval.  All values generated will be
    less than high.  The default value is 1.0.
size : tuple of ints, int, optional
    Shape of output.  If the given size is, for example, (m,n,k),
    m*n*k samples are generated.  If no shape is specified, a single sample
    is returned.

Returns
-------
out : ndarray
    Drawn samples, with shape `size`.

See Also
--------
randint : Discrete uniform distribution, yielding integers.
random\_integers : Discrete uniform distribution over the closed interval
                  ``[low, high]``.
random\_sample : Floats uniformly distributed over ``[0, 1)``.
random : Alias for `random\_sample`.
rand : Convenience function that accepts dimensions as input, e.g.,
       ``rand(2,2)`` would generate a 2-by-2 array of floats, uniformly
       distributed over ``[0, 1)``.

Notes
-----
The probability density function of the uniform distribution is

.. math:: p(x) = {\textbackslash}frac\{1\}\{b - a\}

anywhere within the interval ``[a, b)``, and zero elsewhere.

Examples
--------
Draw samples from the distribution:

{\textgreater}{\textgreater}{\textgreater} s = np.random.uniform(-1,0,1000)

All values are within the given interval:

{\textgreater}{\textgreater}{\textgreater} np.all(s {\textgreater}= -1)
True

{\textgreater}{\textgreater}{\textgreater} np.all(s {\textless} 0)
True

Display the histogram of the samples, along with the
probability density function:

{\textgreater}{\textgreater}{\textgreater} import matplotlib.pyplot as plt
{\textgreater}{\textgreater}{\textgreater} count, bins, ignored = plt.hist(s, 15, normed=True)
{\textgreater}{\textgreater}{\textgreater} plt.plot(bins, np.ones\_like(bins), linewidth=2, color='r')
{\textgreater}{\textgreater}{\textgreater} plt.show()
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{peach.sa}\texttt{'}}&\\
\cline{1-2}
\raggedright a\-b\-s\- & \raggedright \textbf{Value:} 
{\tt {\textless}ufunc 'absolute'{\textgreater}}&\\
\cline{1-2}
\raggedright e\-x\-p\- & \raggedright \textbf{Value:} 
{\tt {\textless}ufunc 'exp'{\textgreater}}&\\
\cline{1-2}
\raggedright i\-s\-n\-a\-n\- & \raggedright \textbf{Value:} 
{\tt {\textless}ufunc 'isnan'{\textgreater}}&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.sa \textit{(package)}|)}

%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.nn.base
%
% Generated by epydoc 3.0beta1
% [Mon Dec 21 08:51:37 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}|(}
\section{Module peach.nn.base}

    \label{peach:nn:base}

Basic definitions for layers of neurons.

This subpackage implements the basic classes used with neural networks. A neural
network is basically implemented as a layer of neurons. To speed things up, a
layer is implemented as a array, where each line represents the weight vector
of a neuron. Further definitions and algorithms are based on this definition.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright \_\-B\-I\-A\-S\- & \raggedright This constant vector is defined to implement in a fast way the bias of a
neuron, as an input of value 1, stacked over the real input to the neuron.

\textbf{Value:} 
{\tt array([[ 1.]])}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}|(}
\subsection{Class Layer}

    \label{peach:nn:base:Layer}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{peach.nn.base.Layer}}
\end{tabular}

\textbf{Known Subclasses:} peach.nn.nn.SOM


Base class for neural networks.

This class implements a layer of neurons. It is represented by a array of
real values. Each line of the array represents the weight vector of a
single neuron. If the neurons on the layer are biased, then the first
element of the weight vector is the bias weight, and the bias input is
always valued 1. Also, to each layer is associated an activation function,
that determines if the neuron is fired or not. Please, consult the module
\texttt{af} to see more about activation functions.

In general, this class shoulb be subclassed if you want to use neural nets.
But, as neural nets are very different one from the other, check carefully
the documentation to see if the attributes, properties and methods are
suited to your task.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{peach:nn:base:Layer:__call__}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_call\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_call\_\_}(\textit{self}, \textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

The feedforward method to the layer.

The \texttt{{\_}{\_}call{\_}{\_}} interface should be called if the answer of the neuron
to a given input vector \texttt{x} is desired. \emph{This method has collateral
effects}, so beware. After the calling of this method, the \texttt{v} and
\texttt{y} properties are set with the activation potential and the answer of
the neurons, respectivelly.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{x}

          \item[x]


The input vector to the layer.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}

The vector containing the answer of every neuron in the layer, in the
respective order.
      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__delattr__}
    \index{object.\_\_delattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}delattr{\_}{\_}('name') {\textless}=={\textgreater} del x.name
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__getattribute__}
    \index{object.\_\_getattribute\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getattribute\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}getattribute{\_}{\_}('name') {\textless}=={\textgreater} x.name
    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getbias}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getbias \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getbias}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getinputs}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getinputs \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getinputs}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getitem__}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getitem\_\_}(\textit{self}, \textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

The \texttt{{[} {]}} get interface.

The input to this method is forwarded to the \texttt{weights} property. That
means that it will return the respective line/element of the weight
array.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{x}

          \item[n]


A slice object containing the elements referenced. Since it is
forwarded to an array, it behaves exactly as one.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}

The element or elements in the referenced indices.
      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getphi}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getphi \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getphi}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getshape}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getshape \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getshape}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getsize}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getsize \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getsize}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getv}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getv \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getv}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__getweights}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_getweights \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getweights}(\textit{self})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__gety}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_gety \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_gety}(\textit{self})

    \end{boxedminipage}

    \label{object:__hash__}
    \index{object.\_\_hash\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_hash\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

hash(x)
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{shape}, \textit{phi}=\texttt{{\textless}class 'peach.nn.af.Linear'{\textgreater}}, \textit{bias}=\texttt{False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Initializes the layer.

A layer is represented by a array where each line is the weight vector
of a single neuron. The first element of the vector is the bias weight,
in case the neuron is biased. Associated with the layer is an activation
function defined in an appropriate way.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{xxxxx}

          \item[shape]


Stablishes the size of the layer. It must be a two-tuple of the
format \texttt{(m, n)}, where \texttt{m} is the number of neurons in the
layer, and \texttt{n} is the number of inputs of each neuron. The neurons
in the layer all have the same number of inputs.
          \item[phi]


The activation function. It can be an \texttt{Activation} object (please,
consult the \texttt{af} module) or a standard Python function. In this
case, it must receive a single real value and return a single real
value which determines if the neuron is activated or not. Defaults
to \texttt{Linear}.
          \item[bias]


If \texttt{True}, then the neurons on the layer are biased. That means
that an additional weight is added to each neuron to represent the
bias. If \texttt{False}, no modification is made.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{object:__new__}
    \index{object.\_\_new\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{T}, \textit{S}, \textit{...})

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
a new object with type S, a subtype of T
\end{alltt}

      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__reduce__}
    \index{object.\_\_reduce\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

helper for pickle
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__reduce_ex__}
    \index{object.\_\_reduce\_ex\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_ex\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

helper for pickle
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__repr__}
    \index{object.\_\_repr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

repr(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__setattr__}
    \index{object.\_\_setattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}setattr{\_}{\_}('name', value) {\textless}=={\textgreater} x.name = value
    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__setitem__}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_setitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setitem\_\_}(\textit{self}, \textit{n}, \textit{w})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

The \texttt{{[} {]}} set interface.

The inputs to this method are forwarded to the \texttt{weights} property.
That means that it will set the respective line/element of the weight
array.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{x}

          \item[n]


A slice object containing the elements referenced. Since it is
forwarded to an array, it behaves exactly as one.
          \item[w]


A value or array of values to be set in the given indices.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__setphi}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_setphi \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setphi}(\textit{self}, \textit{phi})

    \end{boxedminipage}

    \label{peach:nn:base:Layer:__setweights}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}!peach.nn.base.Layer.\_\_setweights \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setweights}(\textit{self}, \textit{m})

    \end{boxedminipage}

    \label{object:__str__}
    \index{object.\_\_str\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

str(x)
    \vspace{1ex}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-c\-l\-a\-s\-s\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt {\textless}attribute '\_\_class\_\_' of 'object' objects{\textgreater}}&\\
\cline{1-2}
\raggedright b\-i\-a\-s\- & \raggedright True if the neuron is biased. Not writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf98ec{\textgreater}}&\\
\cline{1-2}
\raggedright i\-n\-p\-u\-t\-s\- & \raggedright Number of inputs for each neuron in the layer. Not writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf989c{\textgreater}}&\\
\cline{1-2}
\raggedright p\-h\-i\- & \raggedright The activation function. It can be set with an \texttt{Activation} instance or
a standard Python function. If a standard function is given, it must receive
a real value and return a real value that is the activation value of the
neuron. In that case, it is adjusted to work accordingly with the internals
of the layer.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf993c{\textgreater}}&\\
\cline{1-2}
\raggedright s\-h\-a\-p\-e\- & \raggedright Shape of the layer, given in the format of a tuple \texttt{(m, n)}, where
\texttt{m} is the number of neurons in the layer, and \texttt{n} is the number of
inputs in each neuron. Not writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf98c4{\textgreater}}&\\
\cline{1-2}
\raggedright s\-i\-z\-e\- & \raggedright Number of neurons in the layer. Not writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf9874{\textgreater}}&\\
\cline{1-2}
\raggedright v\- & \raggedright The activation potential of the neuron. Not writable, and only available
after the neuron is fed some input.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf9964{\textgreater}}&\\
\cline{1-2}
\raggedright w\-e\-i\-g\-h\-t\-s\- & \raggedright A \texttt{numpy} array containing the synaptic weights of the network. Each
line is the weight vector of a neuron. It is writable, but the new weight
array must be the same shape of the neuron, or an exception is raised.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf9914{\textgreater}}&\\
\cline{1-2}
\raggedright y\- & \raggedright The activation value of the neuron. Not writable, and only available
after the neuron is fed some input.

\textbf{Value:} 
{\tt {\textless}property object at 0x8cf998c{\textgreater}}&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}!peach.nn.base.Layer \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.nn \textit{(package)}!peach.nn.base \textit{(module)}|)}

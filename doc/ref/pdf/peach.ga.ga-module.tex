%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.ga.ga
%
% Generated by epydoc 3.0beta1
% [Mon Dec 21 08:51:36 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}|(}
\section{Module peach.ga.ga}

    \label{peach:ga:ga}

Basic Genetic Algorithm (GA)

This sub-package implements a traditional genetic algorithm as described in
books and papers. It consists of selecting, breeding and mutating a population
of chromosomes (arrays of bits) and reinserting the fittest individual from the
previous generation if the GA is elitist. Please, consult a good reference on
the subject, for the subject is way too complicated to be explained here.

Within the algorithm implemented here, it is possible to specify and configure
the selection, crossover and mutation methods using the classes in the
respective sub-modules and custom methods can be implemented (check
\texttt{selection}, \texttt{crossover} and \texttt{mutation} modules).

A GA object is actually a list of chromosomes. Please, refer to the
documentation of the class below for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright a\-d\-d\- & \raggedright \textbf{Value:} 
{\tt {\textless}ufunc 'add'{\textgreater}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}|(}
\subsection{Class GA}

    \label{peach:ga:ga:GA}
\begin{tabular}{cccccccc}
% Line for object, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for list, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{list}\multirow{2}{\BCL}{list}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{peach.ga.ga.GA}}
\end{tabular}


A standard Genetic Algorithm

This class implements the methods to generate, initialize and evolve a
population of chromosomes according to a given fitness function. A standard
GA implements, in this order:
\begin{quote}
\begin{itemize}
\item {} 
A selection method, to choose, from this generation, which individuals
will be present in the next generation;

\item {} 
A crossover method, to exchange information between selected individuals
to add diversity to the population;

\item {} 
A mutation method, to change information in a selected individual, also
to add diversity to the population;

\item {} 
The reinsertion of the fittest individual, if the population is elitist
(which is almost always the case).

\end{itemize}
\end{quote}

A population is actually a list of chromosomes, and individuals can be
read and set as in a normal list. Use the \texttt{{[} {]}} operators to access
individual chromosomes but please be aware that modifying the information on
the list before the end of convergence can cause unpredictable results. The
population and the algorithm have also other properties, check below to see
more information on them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{fitness}, \textit{fmt}, \textit{ranges}=\texttt{\texttt{[}\texttt{]}}, \textit{size}=\texttt{50}, \textit{selection}=\texttt{{\textless}class 'peach.ga.selection.RouletteWheel'{\textgreater}}, \textit{crossover}=\texttt{{\textless}class 'peach.ga.crossover.TwoPoint'{\textgreater}}, \textit{mutation}=\texttt{{\textless}class 'peach.ga.mutation.BitToBit'{\textgreater}}, \textit{elitist}=\texttt{True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Initializes the population and the algorithm.

On the initialization of the population, a lot of parameters can be set.
Those will deeply affect the results. The parameters are:
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{xxxxxxxxx}

          \item[fitness]


A fitness function to serve as an objective function. In general, a
GA is used for maximizing a function. This parameter can be a
standard Python function or a \texttt{Fitness} instance.

In the first case, the GA will convert the function in a
\texttt{Fitness} instance and call it internally when needed. The
function should receive a tuple or vector of data according to the
given \texttt{Chromosome} format (see below) and return a numeric value.

In the second case, you can use any of the fitness methods of the
\texttt{fitness} sub-module, or create your own. If you want to use your
own fitness method (for experimentation or simulation, for example),
it must be an instance of a \texttt{Fitness} or of a subclass, or an
exception will be raised. Please consult the documentation on the
\texttt{fitness} sub-module.
          \item[fmt]


A \texttt{struct}-format string. The \texttt{struct} module is a standard
Python module that packs and unpacks informations in bits. These
are used to inform the algorithm what types of data are to be used.
For example, if you are maximizing a function of three real
variables, the format should be something like \texttt{"fff"}. Any type
supported by the \texttt{struct} module can be used. The GA will decode
the bit array according to this format and send it as is to your
fitness function -{}- your function \emph{must} know what to do with them.

Alternatively, the format can be an integer. In that case, the GA
will not try to decode the bit sequence. Instead, the bits are
passed without modification to the objective function, which must
deal with them. Notice that, if this is used this way, the
\texttt{ranges} property (see below) makes no sense, so it is set to
\texttt{None}. Also, no sanity checks will be performed.
          \item[ranges]


Since messing with the bits can change substantially the values
obtained can diverge a lot from the maximum point. To avoid this,
you can specify a range for each of the variables. \texttt{range}
defaults to \texttt{{[} {]}}, this means that no range checkin will be done.
If given, then every variable will be checked. There are two ways to
specify the ranges.

It might be a tuple of two values, \texttt{(x0, x1)}, where \texttt{x0} is the
start of the interval, and \texttt{x1} its end. Obviously, \texttt{x0} should
be smaller than \texttt{x1}. If \texttt{range} is given in this way, then this
range will be used for every variable.

If can be specified as a list of tuples with the same format as
given above. In that case, the list must have one range for every
variable specified in the format and the ranges must appear in the
same order as there. That is, every variable must have a range
associated to it.
          \item[size]


This is the size of the population. It defaults to 50.
          \item[selection]


This specifies the selection method. You can use one given in the
\texttt{selection} sub-module, or you can implement your own. In any
case, the \texttt{selection} parameter must be an instance of
\texttt{Selection} or of a subclass. Please, see the documentation on the
\texttt{selection} module for more information. Defaults to
\texttt{RouletteWheel}. If made \texttt{None}, then selection will not be
present in the GA.
          \item[crossover]


This specifies the crossover method. You can use one given in the
\texttt{crossover} sub-module, or you can implement your own. In any
case, the \texttt{crossover} parameter must be an instance of
\texttt{Crossover} or of a subclass. Please, see the documentation on the
\texttt{crossover} module for more information. Defaults to
\texttt{TwoPoint}. If made \texttt{None}, then crossover will not be
present in the GA.
          \item[mutation]


This specifies the mutation method. You can use one given in the
\texttt{mutation} sub-module, or you can implement your own. In any
case, the \texttt{mutation} parameter must be an instance of \texttt{Mutation}
or of a subclass. Please, see the documentation on the \texttt{mutation}
module for more information. Defaults to \texttt{BitToBit}.  If made
\texttt{None}, then mutation will not be present in the GA.
          \item[elitist]


Defines if the population is elitist or not. An elitist population
will never discard the fittest individual when a new generation is
computed. Defaults to \texttt{True}.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
new list
\end{alltt}

      \end{quote}

    \vspace{1ex}

      Overrides: list.\_\_init\_\_

    \end{boxedminipage}

    \label{peach:ga:ga:GA:__get_csize}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}!peach.ga.ga.GA.\_\_get\_csize \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_get\_csize}(\textit{self})

    \end{boxedminipage}

    \label{peach:ga:ga:GA:sanity}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}!peach.ga.ga.GA.sanity \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{sanity}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Sanitizes the chromosomes in the population.

Since not every individual generated by the crossover and mutation
operations might be a valid result, this method verifies if they are
inside the allowed ranges (or if it is a number at all). Each invalid
individual is discarded and a new one is generated.

This method has no parameters and returns no values.
    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:ga:ga:GA:fit}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}!peach.ga.ga.GA.fit \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{fit}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Computes the fitness for each individual of the population.

This method is only an interface to the \texttt{fitness} function passed in
the initialization. It calls the \texttt{Fitness} instance.

This method has no parameters and returns no values.
    \vspace{1ex}

    \end{boxedminipage}

    \label{peach:ga:ga:GA:step}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}!peach.ga.ga.GA.step \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{step}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Computes a new generation of the population, a step of the adaptation.

This method goes through all the steps of the GA, as described above. If
the selection, crossover and mutation operators are defined, they are
applied over the population. If the population is elitist, then the
fittest individual of the past generation is reinserted.

This method has no parameters and returns no values. The GA itself can
be consulted (using \texttt{{[} {]}}) to find the fittest individual which is the
result of the process.
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__add__}
    \index{list.\_\_add\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_add\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x+y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__contains__}
    \index{list.\_\_contains\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_contains\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

y in x
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__delattr__}
    \index{object.\_\_delattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}delattr{\_}{\_}('name') {\textless}=={\textgreater} del x.name
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__delitem__}
    \index{list.\_\_delitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delitem\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

del x{[}y{]}
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__delslice__}
    \index{list.\_\_delslice\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delslice\_\_}(\textit{x}, \textit{i}, \textit{j})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

del x{[}i:j{]}

Use of negative indices is not supported.
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__eq__}
    \index{list.\_\_eq\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_eq\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x==y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__ge__}
    \index{list.\_\_ge\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ge\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textgreater}=y
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getattribute\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}getattribute{\_}{\_}('name') {\textless}=={\textgreater} x.name
    \vspace{1ex}

      Overrides: object.\_\_getattribute\_\_

    \end{boxedminipage}

    \label{list:__getitem__}
    \index{list.\_\_getitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getitem\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{[}y{]}
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__getslice__}
    \index{list.\_\_getslice\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getslice\_\_}(\textit{x}, \textit{i}, \textit{j})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{[}i:j{]}

Use of negative indices is not supported.
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__gt__}
    \index{list.\_\_gt\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_gt\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textgreater}y
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_hash\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

hash(x)
    \vspace{1ex}

      Overrides: object.\_\_hash\_\_

    \end{boxedminipage}

    \label{list:__iadd__}
    \index{list.\_\_iadd\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iadd\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x+=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__imul__}
    \index{list.\_\_imul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_imul\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x*=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__iter__}
    \index{list.\_\_iter\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iter\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

iter(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__le__}
    \index{list.\_\_le\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_le\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textless}=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__len__}
    \index{list.\_\_len\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_len\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

len(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__lt__}
    \index{list.\_\_lt\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_lt\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textless}y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__mul__}
    \index{list.\_\_mul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_mul\_\_}(\textit{x}, \textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x*n
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__ne__}
    \index{list.\_\_ne\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ne\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x!=y
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{T}, \textit{S}, \textit{...})

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
a new object with type S, a subtype of T
\end{alltt}

      \end{quote}

    \vspace{1ex}

      Overrides: object.\_\_new\_\_

    \end{boxedminipage}

    \label{object:__reduce__}
    \index{object.\_\_reduce\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

helper for pickle
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__reduce_ex__}
    \index{object.\_\_reduce\_ex\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_ex\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

helper for pickle
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

repr(x)
    \vspace{1ex}

      Overrides: object.\_\_repr\_\_

    \end{boxedminipage}

    \label{list:__reversed__}
    \index{list.\_\_reversed\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reversed\_\_}(\textit{L})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

return a reverse iterator over the list
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__rmul__}
    \index{list.\_\_rmul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_rmul\_\_}(\textit{x}, \textit{n})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

n*x
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__setattr__}
    \index{object.\_\_setattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}setattr{\_}{\_}('name', value) {\textless}=={\textgreater} x.name = value
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__setitem__}
    \index{list.\_\_setitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setitem\_\_}(\textit{x}, \textit{i}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{[}i{]}=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:__setslice__}
    \index{list.\_\_setslice\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setslice\_\_}(\textit{x}, \textit{i}, \textit{j}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{[}i:j{]}=y

Use  of negative indices is not supported.
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__str__}
    \index{object.\_\_str\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

str(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:append}
    \index{list.append \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{append}(\textit{L}, \textit{object})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

append object to end
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:count}
    \index{list.count \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{count}(\textit{L}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

return number of occurrences of value
    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
integer
\end{alltt}

      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{list:extend}
    \index{list.extend \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{extend}(\textit{L}, \textit{iterable})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

extend list by appending elements from the iterable
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:index}
    \index{list.index \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{index}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

L.index(value, {[}start, {[}stop{]}{]}) -{\textgreater} integer -{}- return first index of value
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:insert}
    \index{list.insert \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{insert}(\textit{L}, \textit{index}, \textit{object})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

insert object before index
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:pop}
    \index{list.pop \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{pop}(\textit{L}, \textit{index}=\texttt{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

remove and return item at index (default last)
    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
item
\end{alltt}

      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{list:remove}
    \index{list.remove \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{remove}(\textit{L}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

remove first occurrence of value
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:reverse}
    \index{list.reverse \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{reverse}(\textit{L})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

reverse \emph{IN PLACE}
    \vspace{1ex}

    \end{boxedminipage}

    \label{list:sort}
    \index{list.sort \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{sort}(\textit{L}, \textit{cmp}=\texttt{None}, \textit{key}=\texttt{None}, \textit{reverse}=\texttt{False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

stable sort \emph{IN PLACE};
cmp(x, y) -{\textgreater} -1, 0, 1
    \vspace{1ex}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright c\-h\-r\-o\-m\-o\-s\-o\-m\-e\-\_\-s\-i\-z\-e\- & \raggedright This property hold the chromosome size for the population. Not
writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8c3e5f4{\textgreater}}&\\
\cline{1-2}
\raggedright \_\-\_\-c\-l\-a\-s\-s\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt {\textless}attribute '\_\_class\_\_' of 'object' objects{\textgreater}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright r\-a\-n\-g\-e\-s\- & Holds the ranges for every variable. Although it is a writable
property, care should be taken in changing parameters before ending
the convergence.&\\
\cline{1-2}
\raggedright e\-l\-i\-t\-i\-s\-t\- & If \texttt{True}, then the population is elitist.&\\
\cline{1-2}
\raggedright f\-i\-t\-n\-e\-s\-s\- & Vector containing the computed fitness value for every individual.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}!peach.ga.ga.GA \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.ga \textit{(module)}|)}

%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.ga.chromosome
%
% Generated by epydoc 3.0beta1
% [Mon Dec 21 08:51:36 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}|(}
\section{Module peach.ga.chromosome}

    \label{peach:ga:chromosome}

Basic definitions and classes for manipulating chromosomes

This sub-package is a vital part of the genetic algorithms framework within the
module. This uses the \texttt{bitarray} module to implement a chromosome as an array
of bits. It is, thus, necessary that this module is installed in your Python
system. Please, check within the Python website how to install the \texttt{bitarray}
module.

The class defined in this module is derived from \texttt{bitarray} and can also be
derived if needed. In general, users or programmers won't need to instance this
class directly -{}- it is manipulated by the genetic algorithm itself. Check the
class definition for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}!peach.ga.chromosome.Chromosome \textit{(class)}|(}
\subsection{Class Chromosome}

    \label{peach:ga:chromosome:Chromosome}
\begin{tabular}{cccccccccc}
% Line for object, linespec=[False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for bitarray.\_bitarray, linespec=[False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{bitarray.\_bitarray}\multirow{2}{\BCL}{bitarray.\_bitarray}}
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for bitarray.bitarray, linespec=[False]
\multicolumn{6}{r}{\settowidth{\BCL}{bitarray.bitarray}\multirow{2}{\BCL}{bitarray.bitarray}}
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&\multicolumn{2}{l}{\textbf{peach.ga.chromosome.Chromosome}}
\end{tabular}


Implements a chromosome as a bit array.

Data is structured according to the \texttt{struct} module that exists in the
Python standard library. Internally, data used in optimization with a
genetic algorithm are represented as arrays of bits, so the \texttt{bitarray}
module must be installed. Please consult the Python package index for more
information on how to install \texttt{bitarray}. In general, the user don't need
to worry about how the data is manipulated internally, but a specification
of the format as in the \texttt{struct} module is needed.

If the internal format of the data is specified as an \texttt{struct} format, the
genetic algorithm will take care of encoding and decoding data from and to
the optimizer. However, it is possible to specify, instead of a format, the
length of the chromosome. In that case, the fitness function must deal with
the encoding and decoding of the information. It is strongly suggested that
you use \texttt{struct} format strings, as they are much easier. This second
option is provided as a convenience.

The \texttt{Chromosome} class is derived from the \texttt{bitarray} class. So, every
property and method of this class should be accessible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{cls}, \textit{fmt}=\texttt{\texttt{'}\texttt{}\texttt{'}}, \textit{endian}=\texttt{\texttt{'}\texttt{little}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Allocates new memory space for the chromosome

This function overrides the \texttt{bitarray.{\_}{\_}new{\_}{\_}} function to deal with
the length of the chromosome. It should never be directly used, as it is
automatically called by the Python interpreter in the moment of object
creation.
    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}

A new \texttt{Chromosome} object.
      \end{quote}

    \vspace{1ex}

      Overrides: bitarray.\_bitarray.\_\_new\_\_

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{fmt}=\texttt{\texttt{'}\texttt{}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Initializes the chromosome.

This method is automatically called by the Python interpreter and
initializes the data in the chromosome. No data should be provided to be
encoded in the chromosome, as it is usually better start with random
estimates. This method, in particular, does not clear the memory used in
the time of creation of the \texttt{bitarray} from which a \texttt{Chromosome}
derives -{}- so the random noise in the memory is used as initial value.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{xxx}

          \item[fmt]


This parameter can be passed in two different ways. If \texttt{fmt} is a
string, then it is assumed to be a \texttt{struct}-format string. Its
size is calculated and a \texttt{bitarray} of the corresponding size is
created. Please, consult the \texttt{struct} documentation, since what is
explained there is exactly what is used here. For example, if you
are going to use the optimizer to deal with three-dimensional
vectors of continuous variables, the format would be something
like:
\begin{quote}{\ttfamily \raggedright \noindent
fmt~=~'fff'
}\end{quote}

If \texttt{fmt}, however, is an integer, then a \texttt{bitarray} of the given
length is created. Note that, in this case, no format is given to
the chromosome, and it is responsability of the programmer and the
fitness function to provide for it.

Default value is an empty string.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{peach:ga:chromosome:Chromosome:__get_size}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}!peach.ga.chromosome.Chromosome \textit{(class)}!peach.ga.chromosome.Chromosome.\_\_get\_size \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_get\_size}(\textit{self})

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{decode}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

This method decodes the information given in the chromosome.

Data in the chromosome is encoded as a \texttt{struct}-formated string in a
\texttt{bitarray} object. This method decodes the information and returns the
encoded values. If a format string is not given, then it is assumed that
this chromosome is just an array of bits, which is returned.
    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}

A tuple containing the decoded values, in the order specified by the
format string.
      \end{quote}

    \vspace{1ex}

      Overrides: bitarray.\_bitarray.decode

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{encode}(\textit{self}, \textit{values})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

This method encodes the information into the chromosome.

Data in the chromosome is encoded as a \texttt{struct}-formated string in a
\texttt{bitarray} object. This method encodes the given information in the
bitarray. If a format string is not given, this method raises a
\texttt{TypeError} exception.
    \vspace{1ex}

      \textbf{Parameters}
      \begin{quote}
        \begin{Ventry}{xxxxxx}

          \item[values]


A tuple containing the values to be encoded in an order consistent
with the given \texttt{struct}-format.
        \end{Ventry}

      \end{quote}

    \vspace{1ex}

      Overrides: bitarray.\_bitarray.encode

    \end{boxedminipage}

    \label{bitarray:_bitarray:__add__}
    \index{bitarray.\_bitarray.\_\_add\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_add\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__and__}
    \index{bitarray.\_bitarray.\_\_and\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_and\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__contains__}
    \index{bitarray.\_bitarray.\_\_contains\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_contains\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return True if bitarray contains x, False otherwise.
If x is an integer (which includes booleans), it is determined
whether or not the corresponding bit is contained in the bitarray.
If x is an object which can be cast into a bitarray, such as e.g.
the string '0110', a list, or a bitarray itself, a sequential search
will be performed to determine return value.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__copy__}
    \index{bitarray.\_bitarray.\_\_copy\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_copy\_\_}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a copy of the bitarray.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__deepcopy__}
    \index{bitarray.\_bitarray.\_\_deepcopy\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_deepcopy\_\_}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a copy of the bitarray.
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__delattr__}
    \index{object.\_\_delattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}delattr{\_}{\_}('name') {\textless}=={\textgreater} del x.name
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__delitem__}
    \index{bitarray.\_bitarray.\_\_delitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delitem\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__eq__}
    \index{bitarray.\_bitarray.\_\_eq\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_eq\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x==y
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__ge__}
    \index{bitarray.\_bitarray.\_\_ge\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ge\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textgreater}=y
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getattribute\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}getattribute{\_}{\_}('name') {\textless}=={\textgreater} x.name
    \vspace{1ex}

      Overrides: object.\_\_getattribute\_\_

    \end{boxedminipage}

    \label{bitarray:_bitarray:__getitem__}
    \index{bitarray.\_bitarray.\_\_getitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getitem\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__gt__}
    \index{bitarray.\_bitarray.\_\_gt\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_gt\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textgreater}y
    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__hash__}
    \index{object.\_\_hash\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_hash\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

hash(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__iadd__}
    \index{bitarray.\_bitarray.\_\_iadd\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iadd\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__iand__}
    \index{bitarray.\_bitarray.\_\_iand\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iand\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__imul__}
    \index{bitarray.\_bitarray.\_\_imul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_imul\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__invert__}
    \index{bitarray.\_bitarray.\_\_invert\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_invert\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__ior__}
    \index{bitarray.\_bitarray.\_\_ior\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ior\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__iter__}
    \index{bitarray.\_bitarray.\_\_iter\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iter\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

iter(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__ixor__}
    \index{bitarray.\_bitarray.\_\_ixor\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ixor\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__le__}
    \index{bitarray.\_bitarray.\_\_le\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_le\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textless}=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__len__}
    \index{bitarray.\_bitarray.\_\_len\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_len\_\_}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return the length, i.e. number of bits stored in the bitarray.
This method will fail for a bitarray object with 2{\textasciicircum}31 or more elements
on a 32bit machine.  Use bitarray.length() instead.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__lt__}
    \index{bitarray.\_bitarray.\_\_lt\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_lt\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x{\textless}y
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__mul__}
    \index{bitarray.\_bitarray.\_\_mul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_mul\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:__ne__}
    \index{bitarray.\_bitarray.\_\_ne\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_ne\_\_}(\textit{x}, \textit{y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x!=y
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__or__}
    \index{bitarray.\_bitarray.\_\_or\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_or\_\_}(\textit{...})

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return state information for pickling.
    \vspace{1ex}

      Overrides: object.\_\_reduce\_\_

    \end{boxedminipage}

    \label{object:__reduce_ex__}
    \index{object.\_\_reduce\_ex\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_ex\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

helper for pickle
    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

repr(x)
    \vspace{1ex}

      Overrides: object.\_\_repr\_\_

    \end{boxedminipage}

    \label{bitarray:_bitarray:__rmul__}
    \index{bitarray.\_bitarray.\_\_rmul\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_rmul\_\_}(\textit{...})

    \end{boxedminipage}

    \label{object:__setattr__}
    \index{object.\_\_setattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

x.{\_}{\_}setattr{\_}{\_}('name', value) {\textless}=={\textgreater} x.name = value
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__setitem__}
    \index{bitarray.\_bitarray.\_\_setitem\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setitem\_\_}(\textit{...})

    \end{boxedminipage}

    \label{object:__str__}
    \index{object.\_\_str\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

str(x)
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:__xor__}
    \index{bitarray.\_bitarray.\_\_xor\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_xor\_\_}(\textit{...})

    \end{boxedminipage}

    \label{bitarray:_bitarray:all}
    \index{bitarray.\_bitarray.all \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{all}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Returns True when all bits in the array are True.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:any}
    \index{bitarray.\_bitarray.any \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{any}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Returns True when any bit in the array is True.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:append}
    \index{bitarray.\_bitarray.append \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{append}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Append the value bool(x) to the end of the bitarray.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:buffer_info}
    \index{bitarray.\_bitarray.buffer\_info \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{buffer\_info}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a tuple (address, size, endianness, unused, allocated) giving the
current memory address, the size (in bytes) used to hold the bitarray's
contents, the bit endianness as a string, the number of unused bits
(e.g. a bitarray of length 11 will have a buffer size of 2 bytes and
5 unused bits), and the size (in bytes) of the allocated memory.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:bytereverse}
    \index{bitarray.\_bitarray.bytereverse \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{bytereverse}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

For all bytes representing the bitarray, reverse the bit order (in-place).
Note: This method changes the actual machine values representing the
bitarray; it does not change the endianness of the bitarray object.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:copy}
    \index{bitarray.\_bitarray.copy \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{copy}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a copy of the bitarray.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:count}
    \index{bitarray.\_bitarray.count \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{count}(\textit{x}=\texttt{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return number of occurrences of x in the bitarray.  x defaults to True.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:endian}
    \index{bitarray.\_bitarray.endian \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{endian}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return the bit endianness as a string (either 'little' or 'big').
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:extend}
    \index{bitarray.\_bitarray.extend \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{extend}(\textit{object})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Append bits to the end of the bitarray.  The objects which can be passed
to this method are the same iterable objects which can given to a bitarray
object upon initialization.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:fill}
    \index{bitarray.\_bitarray.fill \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{fill}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Returns the number of bits added (0..7) at the end of the array.
When the length of the bitarray is not a multiple of 8, increase the length
slightly such that the new length is a multiple of 8, and set the few new
bits to False.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:fromfile}
    \index{bitarray.\_bitarray.fromfile \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{fromfile}(\textit{f}, \textit{n}=\texttt{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Read n bytes from the file object f and append them to the bitarray
interpreted as machine values.  When n is omitted, as many bytes are
read until EOF is reached.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:fromstring}
    \index{bitarray.\_bitarray.fromstring \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{fromstring}(\textit{string})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Append from a string, interpreting the string as machine values.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:index}
    \index{bitarray.\_bitarray.index \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{index}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return index of first occurrence of x in the bitarray.
It is an error when x does not occur in the bitarray
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:insert}
    \index{bitarray.\_bitarray.insert \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{insert}(\textit{i}, \textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Insert a new item x into the bitarray before position i.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:invert}
    \index{bitarray.\_bitarray.invert \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{invert}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Invert all bits in the array (in-place),
i.e. convert each 1-bit into a 0-bit and vice versa.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:length}
    \index{bitarray.\_bitarray.length \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{length}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return the length, i.e. number of bits stored in the bitarray.
This method is preferred over {\_}{\_}len{\_}{\_}, {[}used when typing \texttt{len(a)}{]},
since {\_}{\_}len{\_}{\_} will fail for a bitarray object with 2{\textasciicircum}31 or more elements
on a 32bit machine, whereas this method will return the correct value,
on 32bit and 64bit machines.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:pack}
    \index{bitarray.\_bitarray.pack \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{pack}(\textit{string})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Extend the bitarray from a string, where each characters corresponds to
a single bit.  The character 'x00' maps to bit 0 and all other characters
map to bit 1.
This method, as well as the unpack method, are meant for efficient
transfer of data between bitarray objects to other python objects
(for example NumPy's ndarray object) which have a different view of memory.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:pop}
    \index{bitarray.\_bitarray.pop \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{pop}(\textit{i}=\texttt{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return the i-th element and delete it from the bitarray. i defaults to -1.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:remove}
    \index{bitarray.\_bitarray.remove \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{remove}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Remove the first occurrence of x in the bitarray.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:reverse}
    \index{bitarray.\_bitarray.reverse \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{reverse}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Reverse the order of bits in the array (in-place).
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:search}
    \index{bitarray.\_bitarray.search \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{search}(\textit{x}, \textit{limit}=\texttt{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Given a bitarray x (or an object which can be converted to a bitarray),
returns the start positions of x matching self as a list.
The optional argument limits the number of search results to the integer
specified.  By default, all search results are returned.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:setall}
    \index{bitarray.\_bitarray.setall \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{setall}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Set all bits in the bitarray to bool(x).
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:sort}
    \index{bitarray.\_bitarray.sort \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{sort}(\textit{reverse}=\texttt{False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Sort the bits in the array (in-place).
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:to01}
    \index{bitarray.\_bitarray.to01 \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{to01}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a string containing '0's and '1's, representing the bits in the
bitarray object.
Note: To extend a bitarray from a string containing '0's and '1's,
use the extend method.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:tofile}
    \index{bitarray.\_bitarray.tofile \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{tofile}(\textit{f})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Write all bits (as machine values) to the file object f.
When the length of the bitarray is not a multiple of 8,
the remaining bits (1..7) are set to 0.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:tolist}
    \index{bitarray.\_bitarray.tolist \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{tolist}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return an ordinary list with the items in the bitarray.
Note: To extend a bitarray with elements from a list,
use the extend method.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:tostring}
    \index{bitarray.\_bitarray.tostring \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{tostring}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return the string representing (machine values) of the bitarray.
When the length of the bitarray is not a multiple of 8, the few remaining
bits (1..7) are set to 0.
    \vspace{1ex}

    \end{boxedminipage}

    \label{bitarray:_bitarray:unpack}
    \index{bitarray.\_bitarray.unpack \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{unpack}(\textit{zero}=\texttt{'{\textbackslash}x00'}, \textit{one}=\texttt{'{\textbackslash}xff'})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}

Return a string containing one character for each bit in the bitarray,
using the specified mapping.
Note that unpack('0', '1') has the same effect as to01().
See also the pack method.
    \vspace{1ex}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright s\-i\-z\-e\- & \raggedright Property that returns the chromosome size. Not writable.

\textbf{Value:} 
{\tt {\textless}property object at 0x8c1cd4c{\textgreater}}&\\
\cline{1-2}
\raggedright \_\-\_\-c\-l\-a\-s\-s\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt {\textless}attribute '\_\_class\_\_' of 'object' objects{\textgreater}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright f\-o\-r\-m\-a\-t\- & Property that contains the chromosome \texttt{struct} format.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}!peach.ga.chromosome.Chromosome \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}|)}
